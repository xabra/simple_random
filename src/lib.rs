#![allow(dead_code)]

use std::ops::Bound;
use std::ops::RangeBounds;

pub struct SimpleRNG {
    previous: u64,
    m: u64,
    a: u64,
    c: u64,
}

pub struct SimpleRNGBuilder {
    previous: u64,
    m: u64,
    a: u64,
    c: u64,
}
impl SimpleRNGBuilder {
    pub fn new() -> Self {
        //! Create a new SimpleRNGBuilder with default parameters and default seed
        SimpleRNGBuilder {
            previous: 4_562_435, // The seed
            a: 48_271,           // Multiplier
            c: 0,                // Additive constant
            m: 2_147_483_647,    // Moduluo parameter.  Equals 2^31-1  (also equals = MAX:i32)
        }
    }
    pub fn with_seed(mut self, seed: u64) -> Self {
        //! Set the seed of the new RNG
        self.previous = seed;
        self
    }

    pub fn with_params(mut self, a: u64, c: u64, m: u64) -> Self {
        //! Set the params of the new RNG
        self.a = a;
        self.c = c;
        self.m = m;
        self
    }
    pub fn build(self) -> SimpleRNG {
        SimpleRNG {
            previous: self.previous,
            m: self.m,
            a: self.a,
            c: self.c,
        }
    }
}

impl SimpleRNG {
    pub fn random_u64(&mut self) -> u64 {
        //! Returns a pseudo random integer u64 from 0 to max_random.
        let new = (self.a * self.previous + self.c) % self.m;
        self.previous = new;
        new
    }
    pub fn max_random(&self) -> u64 {
        //! Returns the largest  integer generated by the random generator
        self.m - 1
    }

    pub fn random_range(&mut self, range: impl RangeBounds<i32>) -> Result<i32, String> {
        //! Returns a random i32 in range
        let rand: i32 = self.random_u64().try_into().unwrap(); // Convert u64 to i32
        let s = match range.start_bound() {
            Bound::Unbounded => {
                return Err(String::from("Bad Range: Unbounded Start"));
            }
            Bound::Excluded(_start) => {
                return Err(String::from("Bad Range: Excluded Start"));
            }
            Bound::Included(start) => *start,
        };
        let e = match range.end_bound() {
            Bound::Unbounded => {
                return Err(String::from("Bad Range: Unbounded End"));
            }
            Bound::Included(end) => *end,
            Bound::Excluded(end) => *end - 1,
        };
        if e < s {
            return Err(String::from("Bad Range: Empty Range"));
        }
        let n = e - s + 1; // Number of possible output in range
        Ok((rand % n) + s)
    }
    pub fn random_float(&mut self) -> f32 {
        //! Returns a random f32 in the range [0, 1)
        self.random_u64() as f32 / self.m as f32
    }
    pub fn random_bool(&mut self, probablility_true: f32) -> bool {
        //! Returns a bool where the probability of it being true is probablility_true
        self.random_float() < probablility_true
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use assertables::{assert_gt, assert_lt};

    #[test]
    fn correctness() {
        //! Test of correctness from Park & Miller using particular parameters and seed = 1
        let mut rng = SimpleRNGBuilder::new()
            .with_params(16_807, 0, 2_147_483_647)
            .with_seed(1)
            .build();

        for _i in 1..10000 {
            let _ = rng.random_u64();
        }
        let last = rng.random_u64();
        println!("{}", last);
        assert_eq!(last, 1_043_618_065);
    }

    #[test]
    fn bool_fraction() {
        //! Test of boolean random number
        let mut rng = SimpleRNGBuilder::new().with_seed(19000).build();
        let probability_true = 0.6;
        let error = 0.05;

        let mut count = 0;
        let max = 10000;
        for _i in 1..max {
            if rng.random_bool(probability_true) {
                count += 1;
            }
        }
        let fraction_true: f32 = count as f32 / max as f32;
        println!("{}", fraction_true);
        assert_lt!(fraction_true, probability_true + error);
        assert_gt!(fraction_true, probability_true - error);
    }
}
