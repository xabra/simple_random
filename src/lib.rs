#![allow(dead_code)]

use std::ops::RangeBounds;

pub struct SimpleRNG {
    previous: u64,
    m: u64,
    a: u64,
    c: u64,
}

pub struct SimpleRNGBuilder {
    previous: u64,
    m: u64,
    a: u64,
    c: u64,
}
impl SimpleRNGBuilder {
    pub fn new() -> Self {
        //! Create a new SimpleRNGBuilder with default parameters and default seed
        SimpleRNGBuilder {
            previous: 4_562_435, // The seed
            a: 48_271,           // Multiplier
            c: 0,                // Additive constant
            m: 2_147_483_647,    // Moduluo parameter.  Equals 2^31-1  (also equals = MAX:i32)
        }
    }
    pub fn with_seed(mut self, seed: u64) -> Self {
        //! Set the seed of the new RNG
        self.previous = seed;
        self
    }
    pub fn build(self) -> SimpleRNG {
        SimpleRNG {
            previous: self.previous,
            m: self.m,
            a: self.a,
           c: self.c,
        }
    }
}
    impl SimpleRNG {
    pub fn random_u64(&mut self) -> u64 {
        //! Returns a pseudo random integer u64 from 0 to max_random.
        let new = (self.a * self.previous + self.c) % self.m;
        self.previous = new;
        new
    }
    pub fn max_random(&self) -> u64 {
        //! Returns the largest  integer generated by the random generator
        self.m - 1
    }
    pub fn random_range(&mut self, range: impl RangeBounds<i32>) -> i32 {
        let x: u32 = self.random_u64().try_into().unwrap();
        let start = if let range.start_bound();
        let end = range.end_bound();
        
        (x % (start - end)) + start
    }
    pub fn random_float(&mut self) -> f32 {
        self.random_u64() as f32/self.m as f32

    }
        pub fn random_bool(&mut self, probablility_true: f32) -> bool {
             self.random_float() < probablility_true
    }
}

fn takes_range<R: RangeBounds<i32>>(range: R) {
    // ...
}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
    let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
